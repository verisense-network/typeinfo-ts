// Code Generator
import type { TypeInfoData } from './typeinfo-parser';
import { TypeInfoParser } from './typeinfo-parser';
import { TypeGenerator } from './type-generator';
import { FunctionGenerator } from './function-generator';

export class CodeGenerator {
  private parser: TypeInfoParser;
  private typeGenerator: TypeGenerator;
  private functionGenerator: FunctionGenerator;

  constructor(private debug: boolean = false) {
    this.parser = new TypeInfoParser(debug);
    this.typeGenerator = new TypeGenerator(this.parser, debug);
    this.functionGenerator = new FunctionGenerator(this.parser, debug);
  }

  public generateFromJson(data: TypeInfoData): string {
    this.log('Start generating code from type information data...');
    
    // Step 1: Parse data
    this.parser.parseTypeInfo(data);
    
    // Step 2: Generate imports
    const imports = this.generateImports();
    
    // Step 3: Generate type definitions
    const types = this.typeGenerator.generateAllTypes();
    
    // Step 4: Generate API functions
    const functions = this.functionGenerator.generateAllFunctions();
    
    // Step 5: Generate type registration code
    const registration = this.generateTypeRegistration();
    
    // Step 6: Combine all parts
    return this.combineCode(imports, types, functions, registration);
  }

  private generateImports(): string {
    this.log('Generate imports...');
    
    return `/**
 * This is an automatically generated file. DO NOT MODIFY IT DIRECTLY.
 * Generated by typeinfo-ts code generator.
 * WARNING: Any manual changes to this file will be overwritten on next generation
 */
import {
  Text,
  i8,
  I8,
  u8,
  U8,
  u16,
  U16,
  u32,
  U32,
  u64,
  U64,
  i16,
  I16,
  i32,
  I32,
  i64,
  I64,
  i128,
  I128,
  u128,
  U128,
  U8aFixed,
  VecFixed,
  Null,
  Enum,
  Result,
  Vec,
  Tuple,
  Option,
  bool,
  Struct,
  Bytes
} from '@polkadot/types-codec';
import { ApiPromise, HttpProvider } from "@polkadot/api";
import { u8aToHex } from '@polkadot/util';
import { TypeRegistry } from '@polkadot/types';
import type { Registry, Codec } from '@polkadot/types/types';
import type { U8aBitLength } from '@polkadot/types-codec/types';

export const registry: Registry = new TypeRegistry() as unknown as Registry;
let api: ApiPromise;

export async function initApi(endpoint: string): Promise<ApiPromise> {
  const provider = new HttpProvider(endpoint);
  api = await ApiPromise.create({ 
    provider,
    registry 
  });
  return api;
}
`;
  }

  /**
   * Generate type registration code
   */
  private generateTypeRegistration(): string {
    this.log('Generate type registration code...');
    
    const typeNames = this.parser.getTypeNames();
    const registrationEntries: string[] = [];
    
    for (const [id, typeName] of typeNames) {
      const typeInfo = this.parser.getTypes().get(id);
      if (typeInfo && !typeInfo.type.def.primitive) {
        // Skip basic type names to avoid duplicate registration
        if (!this.isBasicTypeName(typeName)) {
          registrationEntries.push(`      ${typeName}: ${typeName}`);
        }
      }
    }

    return `function registerTypes(): Registry {
  try {
    registry.register({
${registrationEntries.join(',\n')}
    });
  } catch (error) {
    console.warn('type register error:', error);
  }
  
  return registry;
}

registerTypes();
`;
  }

  /**
   * Check if it is a basic type name
   */
  private isBasicTypeName(name: string): boolean {
    const basicTypes = [
      'Result', 'Option', 'Vec', 'Tuple', 'Null', 'Text', 'bool',
      'u8', 'u16', 'u32', 'u64', 'u128', 'i8', 'i16', 'i32', 'i64', 'i128',
      'U8aFixed', 'Struct', 'Enum', 'Bytes'
    ];
    return basicTypes.includes(name);
  }

  /**
   * Combine all code parts
   */
  private combineCode(imports: string, types: string, functions: string, registration: string): string {
    this.log('Combine all code parts...');
    
    return `${imports}

${types}
${functions}
${registration}
`;
  }

  /**
   * Validate generated code
   */
  public validateGeneration(data: TypeInfoData): {
    success: boolean;
    errors: string[];
    warnings: string[];
    stats: {
      typesCount: number;
      functionsCount: number;
    };
  } {
    this.log('Validate generated code...');
    
    const errors: string[] = [];
    const warnings: string[] = [];
    
    try {
      this.parser.parseTypeInfo(data);
      
      const types = this.parser.getTypes();
      const functions = this.parser.getFunctions();
      
      for (const [id, typeInfo] of types) {
        const typeName = this.parser.getTypeName(id);
        if (!typeName || typeName === `Type${id}`) {
          warnings.push(`Type ID=${id} cannot infer a suitable name`);
        }
      }
      
      for (const func of functions) {
        if (!func.name || !func.method) {
          errors.push(`Function definition is incomplete: ${JSON.stringify(func)}`);
        }
      }
      
      return {
        success: errors.length === 0,
        errors,
        warnings,
        stats: {
          typesCount: types.size,
          functionsCount: functions.length
        }
      };
      
    } catch (error) {
      errors.push(`Parse failed: ${error instanceof Error ? error.message : String(error)}`);
      return {
        success: false,
        errors,
        warnings,
        stats: {
          typesCount: 0,
          functionsCount: 0
        }
      };
    }
  }

  private log(message: string, data?: unknown): void {
    if (this.debug) {
      console.log(`[CodeGenerator] ${message}`, data || '');
    }
  }
} 